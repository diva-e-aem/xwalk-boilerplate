{"version":3,"mappings":"0JAYO,SAASA,EAAYC,EAAsB,CAChD,OAAOA,EACJ,cACA,QAAQ,cAAe,GAAG,EAC1B,QAAQ,MAAO,GAAG,EAClB,QAAQ,SAAU,EAAE,CACzB,CCdO,SAASC,EAAgBC,EAAyB,CACvDA,GAAA,MAAAA,EAAS,iBAAiB,KAAK,QAAS,GAAM,CAExC,GADF,QAAQ,EAAE,OAAS,EAAE,YACnB,EAAE,OAAS,EAAE,YAAa,CAC5B,MAAMC,EAAK,EAAE,cACPC,EAAQ,EAAE,cAAe,cAC1B,EAAE,cAAc,KAAK,IACpBD,EAAG,WAAW,SAAW,IAAMA,EAAG,UAAY,KAAOA,EAAG,UAAY,SACtE,EAAE,UAAY,SACXA,EAAA,UAAU,IAAI,kBAAkB,GAGnCA,EAAG,WAAW,SAAW,GACzBA,EAAG,UAAY,UACfC,EAAM,WAAW,SAAW,GAC5BA,EAAM,UAAY,MAElB,EAAE,UAAY,iBACRA,EAAA,UAAU,IAAI,kBAAkB,GAGtCD,EAAG,WAAW,SAAW,GACzBA,EAAG,UAAY,MACfC,EAAM,WAAW,SAAW,GAC5BA,EAAM,UAAY,MAElB,EAAE,UAAY,mBACRA,EAAA,UAAU,IAAI,kBAAkB,GAG5C,GAEJ,CCvBO,SAASC,GAAoB,CAClC,OAAOC,IAA4B,OAAO,OAAO,SAAS,OAAS,OAAO,SAAS,MACrF,CCDa,MAAAC,EAAqBC,GAAkC,CAC9D,IACF,MAAMC,EAAWJ,IACXK,EAAW,OAAO,IAAI,aAAa,SAAS,GAAG,EAAI,OAAO,IAAI,aAAe,GAAG,OAAO,IAAI,YAAY,IAC7G,IAAIC,EAAqBH,EAErBA,EAAS,WAAW,IAAI,EACLG,EAAAH,EAAS,UAAU,CAAC,EAChCA,EAAS,WAAW,GAAG,IACXG,EAAAH,EAAS,UAAU,CAAC,GAG3C,MAAMI,EAAW,GAAGF,CAAQ,GAAGC,CAAkB,GAG1C,OAFK,IAAI,IAAIC,EAAUH,CAAQ,QAG/BI,EAAO,CACd,MAAM,IAAI,MAAM,qCAAqCA,CAAK,EAAE,CAC9D,CACF,EC1BO,SAASC,EAAQN,EAAiC,CACvD,OAAO,IAAI,QAAQ,CAACO,EAASC,IAAW,CACtC,KAAM,CAAE,KAAAC,CAAA,EAASV,EAAkBC,CAAQ,EAE3C,GAAK,SAAS,cAAc,qBAAqBS,CAAI,IAAI,EAQ/CF,QARkD,CACpD,MAAAG,EAAO,SAAS,cAAc,MAAM,EAC1CA,EAAK,IAAM,aACXA,EAAK,KAAOD,EACPC,EAAA,OAAS,IAAMH,IACpBG,EAAK,QAAUF,EACN,cAAK,OAAOE,CAAI,EAG3B,CACD,CACH,CCZA,eAAsBC,EAAUC,EAAmC,CAC3D,MAAAC,EAASD,EAAM,QAAQ,YACzB,GAAAC,IAAW,WAAaA,IAAW,SAAU,CAC/CD,EAAM,QAAQ,YAAc,UACtB,MAAE,UAAAE,CAAU,EAAIF,EAAM,QACxB,IACF,MAAMG,EAAY,MAAMT,EAAQ,QAAQQ,CAAS,IAAIA,CAAS,MAAM,EAC9DE,EAAqB,IAAI,QAAeT,GAAY,EACvD,SAAY,CACP,IACI,MAAE,KAAAE,GAASV,EAAkB,QAAQe,CAAS,IAAIA,CAAS,KAAK,EAChEG,EAAM,YAAM,OAAOR,GAAA,qBACrBQ,EAAI,SACA,MAAAA,EAAI,QAAQL,CAAK,QAElBP,EAAO,CACda,EAAgB,MAAM,6BAA6BJ,CAAS,GAAIT,CAAK,CACvE,CACQE,GAAA,IACP,CACJ,EACD,MAAM,QAAQ,IAAI,CAACQ,EAAWC,CAAkB,CAAC,QAC1CX,EAAO,CACda,EAAgB,MAAM,wBAAwBJ,CAAS,GAAIT,CAAK,CAClE,CACAO,EAAM,QAAQ,YAAc,QAC9B,CACF,CC9BsB,eAAAO,EACpBC,EACAC,EACe,CACT,MAAAR,EAASO,EAAQ,QAAQ,cAE3B,IAACP,GAAUA,IAAW,cAAe,CACvCO,EAAQ,QAAQ,cAAgB,UAChC,MAAME,EAAS,CAAC,GAAGF,EAAQ,iBAA8B,WAAW,CAAC,EACrE,QAASG,EAAI,EAAGA,EAAID,EAAO,OAAQC,GAAK,EAEhC,MAAAZ,EAAUW,EAAOC,CAAC,CAAC,EAI3BH,EAAQ,QAAQ,cAAgB,SACxBA,EAAA,MAAM,eAAe,SAAS,CACxC,CACF,CCjBsB,eAAAI,EAAaC,EAA+C,SAAU,CAC1F,GAAIA,EAAe,CAEjB,MAAMC,EADW,CAAC,GAAGD,EAAc,iBAA8B,UAAU,CAAC,EAC1C,IAAKL,GAAYD,EAAYC,CAAO,CAAC,EAEjE,cAAQ,IAAIM,CAAgB,CACpC,CACF,CCXO,SAASC,GAAiB,CACf,SAAS,iBAAiB,kCAAkC,EACpE,QAASC,GAAS,CACxB,MAAMH,EAAgBG,EAAK,cACvBH,GACYA,EAAA,UAAU,IAAI,QAAS,MAAM,CAC7C,CACD,CACH,CCDO,SAASI,EAAaT,EAAyB,CACpD,MAAMU,EAA6B,GACnC,IAAIC,EAAiB,GACrB,CAAC,GAAGX,EAAQ,QAAQ,EAAE,QAAS,GAAM,CACnC,GAAI,EAAE,UAAY,OAAS,CAACW,EAAgB,CACpC,MAAAC,EAAU,SAAS,cAAc,KAAK,EAC5CF,EAAS,KAAKE,CAAO,EACrBD,EAAiB,EAAE,UAAY,MAE3BA,GACMC,EAAA,UAAU,IAAI,yBAAyB,CAEnD,CACAF,EAASA,EAAS,OAAS,CAAC,EAAE,OAAO,CAAC,EACvC,EACDA,EAAS,QAASE,GAAYZ,EAAQ,OAAOY,CAAO,CAAC,EACtCL,IACPP,EAAA,UAAU,IAAI,SAAS,EAC/BA,EAAQ,QAAQ,cAAgB,cAChCA,EAAQ,MAAM,QAAU,MAC1B,CCjBO,SAASa,EAAYzC,EAAsB,CAC5C,4BAAsB,KAAKA,CAAI,EAC1BA,EAGL,sBAAsB,KAAKA,CAAI,EAC1BA,EAAK,OAAO,CAAC,EAAE,cAAgBA,EAAK,MAAM,CAAC,EAG7CD,EAAYC,CAAI,EAAE,QAAQ,YAAc0C,GAAcA,EAAE,CAAC,EAAE,YAAa,EACjF,CCjBO,SAASC,EAAgBvB,EAAmD,CACjF,MAAMwB,EAA4C,GAClD,OAAAxB,EAAM,iBAAiB,cAAc,EAAE,QAASyB,GAAQ,CACtD,GAAIA,EAAI,SAAU,CAChB,MAAMC,EAAO,CAAC,GAAGD,EAAI,QAAQ,EACzB,GAAAC,EAAK,CAAC,EAAG,CACL,MAAAC,EAAMD,EAAK,CAAC,EACZ9C,EAAOD,EAAY+C,EAAK,CAAC,EAAE,aAAe,EAAE,EAClD,IAAIE,EAA2B,GAC3B,GAAAD,EAAI,cAAc,GAAG,EAAG,CAC1B,MAAME,EAAK,CAAC,GAAGF,EAAI,iBAAiB,GAAG,CAAC,EACpCE,EAAG,SAAW,EACRD,EAAAC,EAAG,CAAC,EAAE,KAEdD,EAAQC,EAAG,IAAKC,GAAMA,EAAE,IAAI,CAErB,SAAAH,EAAI,cAAc,KAAK,EAAG,CACnC,MAAMI,EAAO,CAAC,GAAGJ,EAAI,iBAAiB,KAAK,CAAC,EACxCI,EAAK,SAAW,EACVH,EAAAG,EAAK,CAAC,EAAE,IAEhBH,EAAQG,EAAK,IAAKC,GAAQA,EAAI,GAAG,CAE1B,SAAAL,EAAI,cAAc,GAAG,EAAG,CACjC,MAAMM,EAAK,CAAC,GAAGN,EAAI,iBAAiB,GAAG,CAAC,EACpCM,EAAG,SAAW,EACRL,EAAAK,EAAG,CAAC,EAAE,YAEdL,EAAQK,EAAG,IAAKC,GAAMA,EAAE,WAAY,CACtC,MAEQN,EAAAH,EAAI,SAAS,CAAC,EAAE,YAE1BD,EAAO5C,CAAI,EAAIgD,CACjB,CACF,EACD,EACMJ,CACT,CCrCO,SAASW,EAAuB3B,EAAsB,CACrD,MAAA4B,EAAc5B,EAAQ,cAAc,sBAAsB,EAChE,GAAI4B,EAAa,CACT,MAAAC,EAAOd,EAAgBa,CAAW,EACxC,OAAO,KAAKC,CAAI,EAAE,QAASC,GAAQ,CAC7BA,IAAQ,QACMD,EAAK,MAClB,MAAM,GAAG,EACT,OAAQE,GAAkBA,CAAK,EAC/B,IAAKA,GAAkB5D,EAAY4D,EAAM,KAAM,EAAC,EAC5C,QAASA,GAAkB/B,EAAQ,UAAU,IAAI+B,CAAK,CAAC,EAG9D/B,EAAQ,QAAQa,EAAYiB,CAAG,CAAC,EAAID,EAAKC,CAAG,CAC9C,CACD,EACGF,EAAY,eAAeA,EAAY,cAAc,QAC3D,CACF,CCjBO,SAASI,EAAkBC,EAA0B,CAC1DA,GAAA,MAAAA,EAAM,iBAAiC,gBAAgB,QAASjC,GAAY,CAC1ES,EAAaT,CAAO,EACpB2B,EAAuB3B,CAAO,GAElC,CCVO,SAASkC,EAAc1C,EAAoB,CAChD,MAAM2C,EAAgB,CAAC,IAAK,MAAO,KAAM,KAAM,UAAW,QAAS,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,EAE/FC,EAAQC,GAAoB,CAC1B,MAAAzB,EAAU,SAAS,cAAc,GAAG,EAClCA,EAAA,OAAO,GAAGyB,EAAG,UAAU,EAC9B,IAAGA,EAAG,UAAU,EAGd,OACC,CAAC,CAAE,SAAAC,CAAS,IACVA,IAAa,SAAWA,EAAS,WAAW,UAAU,GAAKA,EAAS,WAAW,eAAe,GAEjG,QAAQ,CAAC,CAAE,SAAAA,EAAU,UAAAC,KAAgB,CAC5B3B,EAAA,aAAa0B,EAAUC,GAAa,EAAE,EAC9CF,EAAG,gBAAgBC,CAAQ,EAC5B,EACHD,EAAG,OAAOzB,CAAO,GAGnBpB,EAAM,iBAAiB,oBAAoB,EAAE,QAASgD,GAA6B,SAC7EA,EAAY,kBAEZ,EAAQA,EAAY,mBACpBL,EAAc,KAAMM,GAAY,eAAAC,EAAAF,GAAA,YAAAA,EAAa,oBAAb,YAAAE,EAAgC,WAAYD,EAAO,IAInFC,EAAAF,EAAY,oBAAZ,YAAAE,EAA+B,WAAY,YAC1CF,EAAY,SAAS,OAAS,IAAaG,EAAAH,EAAY,cAAZ,MAAAG,EAAyB,SAErEP,EAAKI,CAAW,EALhBJ,EAAKI,CAAW,EAOpB,CACD,CACH,CCjCO,SAASI,EAAcpD,EAA2B,CACvD,GAAIA,EAAO,CACH,MAAAqD,EAAiBrD,EAAM,UAAU,CAAC,EACxC,GAAIqD,GAAkB,CAACrD,EAAM,QAAQ,YAAa,CAC1CA,EAAA,UAAU,IAAI,OAAO,EAC3BA,EAAM,QAAQ,UAAYqD,EAC1BrD,EAAM,QAAQ,YAAc,cAC5B0C,EAAc1C,CAAK,EACnB,MAAMsD,EAAetD,EAAM,cAC3BsD,GAAA,MAAAA,EAAc,UAAU,IAAI,GAAGD,CAAc,YACvC,MAAA7C,EAAUR,EAAM,QAAQ,UAAU,EACpCQ,GAASA,EAAQ,UAAU,IAAI,GAAG6C,CAAc,YAAY,CAClE,CACF,CACF,CCdO,SAASE,EAAed,EAA0B,CACvDA,GAAA,MAAAA,EAAM,iBAAiC,2BAA2B,QAASzC,GAAU,CACnFoD,EAAcpD,CAAK,GAEvB","names":["toClassName","name","decorateButtons","element","up","twoup","getOrigin","isSidekickLibraryActive","getUrlForEndpoint","endpoint","location","basePath","normalizedEndpoint","fullPath","error","loadCSS","resolve","reject","href","link","loadBlock","block","status","blockName","cssLoaded","decorationComplete","mod","DebuggerService","loadSection","section","loadCallback","blocks","i","loadSections","parentElement","SectionsPromises","decorateImages","item","adjustMarkup","wrappers","defaultContent","wrapper","toCamelCase","g","readBlockConfig","config","row","cols","col","value","as","a","imgs","img","ps","p","processSectionMetaData","sectionMeta","meta","key","style","transformSections","main","wrapTextNodes","validWrappers","wrap","el","nodeName","nodeValue","blockColumn","tagName","_a","_b","decorateBlock","shortBlockName","blockWrapper","decorateBlocks"],"sources":["../../src/utils/toClassName.ts","../../src/app/tasks/decorateButtons.ts","../../src/helpers/sidekick/getOrigin.ts","../../src/app/utils/getUrlForEndpoint.ts","../../src/app/tasks/loadCSS.ts","../../src/app/tasks/loadBlock.ts","../../src/app/tasks/loadSection.ts","../../src/app/tasks/loadSections.ts","../../src/app/tasks/decorateImages.ts","../../src/app/tasks/adjustMarkup.ts","../../src/utils/toCamelCase.ts","../../src/app/tasks/readBlockConfig.ts","../../src/app/tasks/processSectionMetaData.ts","../../src/app/tasks/transformSections.ts","../../src/app/tasks/wrapTextNodes.ts","../../src/app/tasks/decorateBlock.ts","../../src/app/tasks/decorateBlocks.ts"],"sourcesContent":["/**\n * Converts a string into a valid CSS class name.\n *\n * @param {string} name - The string to convert into a CSS class name.\n * @returns {string} The converted CSS class name.\n *\n * @example\n * // Example usage:\n * const inputString = 'Hello, World!';\n * const cssClassName = toClassName(inputString);\n * console.log(cssClassName); // Output: 'hello-world'\n */\nexport function toClassName(name: string): string {\n  return name\n    .toLowerCase()\n    .replace(/[^0-9a-z]/gi, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '');\n}\n","/**\n * Decorates paragraphs containing a single link as buttons.\n * @param {Element} element container element\n */\nexport function decorateButtons(element: Element | null) {\n  element?.querySelectorAll('a').forEach((a) => {\n    a.title = a.title || a.textContent!;\n    if (a.href !== a.textContent) {\n      const up = a.parentElement!;\n      const twoup = a.parentElement!.parentElement!;\n      if (!a.querySelector('img')) {\n        if (up.childNodes.length === 1 && (up.tagName === 'P' || up.tagName === 'DIV')) {\n          a.className = 'button'; // default\n          up.classList.add('button-container');\n        }\n        if (\n          up.childNodes.length === 1 &&\n          up.tagName === 'STRONG' &&\n          twoup.childNodes.length === 1 &&\n          twoup.tagName === 'P'\n        ) {\n          a.className = 'button primary';\n          twoup.classList.add('button-container');\n        }\n        if (\n          up.childNodes.length === 1 &&\n          up.tagName === 'EM' &&\n          twoup.childNodes.length === 1 &&\n          twoup.tagName === 'P'\n        ) {\n          a.className = 'button secondary';\n          twoup.classList.add('button-container');\n        }\n      }\n    }\n  });\n}\n","import { isSidekickLibraryActive } from './isSidekickLibraryActive';\n\n/**\n * Returns the true origin of the current page in the browser.\n * If the page is running in an iframe with srcdoc, the ancestor origin is returned.\n * @returns {String} The true origin\n *\n * @example\n * const origin = getOrigin();\n *\n * @remarks\n * Needs to be used when the Sidekick Library Plugin is in use.\n */\nexport function getOrigin(): string {\n  return isSidekickLibraryActive() ? window.parent.location.origin : window.location.origin;\n}\n","import { getOrigin } from '../../helpers/sidekick/getOrigin';\n\n/**\n * Constructs a complete URL for a given endpoint relative to the base URL.\n * The base URL is derived from `window.hlx.codeBasePath` and the current location.\n * This helper respolves URLs for assets in different AEM contexts. (author, publish, local development, sidekick library etc.)\n * @param {string} endpoint - The endpoint of the asset or fetch request.\n * @returns {URL} - The complete URL for the given endpoint.\n *\n * @example\n * // Assuming window.hlx.codeBasePath is '/base/path/' and the origin is 'https://example.com'\n * const url = getUrlForEndpoint('/api/data');\n * console.log(url.href); // Output: 'https://example.com/base/path/api/data'\n */\nexport const getUrlForEndpoint = (endpoint: string): URL | never => {\n  try {\n    const location = getOrigin();\n    const basePath = window.hlx.codeBasePath.endsWith('/') ? window.hlx.codeBasePath : `${window.hlx.codeBasePath}/`;\n    let normalizedEndpoint = endpoint;\n\n    if (endpoint.startsWith('./')) {\n      normalizedEndpoint = endpoint.substring(2);\n    } else if (endpoint.startsWith('/')) {\n      normalizedEndpoint = endpoint.substring(1);\n    }\n\n    const fullPath = `${basePath}${normalizedEndpoint}`;\n    const url = new URL(fullPath, location);\n\n    return url;\n  } catch (error) {\n    throw new Error(`Failed to build Url for endpoint: ${error}`);\n  }\n};\n","import { getUrlForEndpoint } from '../utils/getUrlForEndpoint';\n\n/**\n * Load a CSS file if it is not already loaded append it to the head.\n * @param {string} endpoint - The endpoint of the CSS file.\n * @returns {Promise<void>}\n */\nexport function loadCSS(endpoint: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const { href } = getUrlForEndpoint(endpoint);\n\n    if (!document.querySelector(`head > link[href=\"${href}\"]`)) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = href;\n      link.onload = () => resolve();\n      link.onerror = reject;\n      document.head.append(link);\n    } else {\n      resolve();\n    }\n  });\n}\n","import { DebuggerService } from '@kluntje/services';\n\nimport { getUrlForEndpoint } from '../utils/getUrlForEndpoint';\nimport { loadCSS } from './loadCSS';\n\n/**\n * Load the es module for the block. The module should be named as the block name.\n * @param {HTMLElement} block - The block to load the module for.\n * @returns {Promise<void>}\n */\nexport async function loadBlock(block: HTMLElement): Promise<void> {\n  const status = block.dataset.blockStatus;\n  if (status !== 'loading' && status !== 'loaded') {\n    block.dataset.blockStatus = 'loading';\n    const { blockName } = block.dataset;\n    try {\n      const cssLoaded = await loadCSS(`dist/${blockName}/${blockName}.css`);\n      const decorationComplete = new Promise<void>((resolve) => {\n        (async () => {\n          try {\n            const { href } = getUrlForEndpoint(`dist/${blockName}/${blockName}.js`);\n            const mod = await import(href);\n            if (mod.default) {\n              await mod.default(block);\n            }\n          } catch (error) {\n            DebuggerService.error(`failed to load module for ${blockName}`, error);\n          }\n          resolve();\n        })();\n      });\n      await Promise.all([cssLoaded, decorationComplete]);\n    } catch (error) {\n      DebuggerService.error(`failed to load block ${blockName}`, error);\n    }\n    block.dataset.blockStatus = 'loaded';\n  }\n}\n","import { loadBlock } from './loadBlock';\n\n/**\n * Load the block modules and styles for a section and show the section.\n * @param {HTMLElement} section - The section to load the block modules and styles for.\n * @returns {Promise<void>}\n */\nexport async function loadSection(\n  section: HTMLElement,\n  loadCallback?: ((arg0: HTMLElement) => any) | undefined\n): Promise<void> {\n  const status = section.dataset.sectionStatus;\n\n  if (!status || status === 'initialized') {\n    section.dataset.sectionStatus = 'loading';\n    const blocks = [...section.querySelectorAll<HTMLElement>('div.block')];\n    for (let i = 0; i < blocks.length; i += 1) {\n      // eslint-disable-next-line no-await-in-loop\n      await loadBlock(blocks[i]);\n    }\n\n    if (loadCallback) await loadCallback(section);\n    section.dataset.sectionStatus = 'loaded';\n    section.style.removeProperty('display');\n  }\n}\n","import { loadSection } from './loadSection';\n\n/**\n * Loads Blocks\n * by getting all sections and load every block in every section\n * and shows every section that is finished loading.\n * @param {Document | HTMLElement | null} parentElement - The parent element to load blocks into.\n */\nexport async function loadSections(parentElement: Document | HTMLElement | null = document) {\n  if (parentElement) {\n    const sections = [...parentElement.querySelectorAll<HTMLElement>('.section')];\n    const SectionsPromises = sections.map((section) => loadSection(section));\n\n    await Promise.all(SectionsPromises);\n  }\n}\n","/*\n * This function is used to decorate images in the default content.\n * It adds the class 'image' and 'main' to the parent element of the image.\n */\nexport function decorateImages() {\n  const picture = document.querySelectorAll('.default-content-wrapper picture');\n  picture.forEach((item) => {\n    const parentElement = item.parentElement;\n    if (parentElement) {\n      parentElement.classList.add('image', 'main');\n    }\n  });\n}\n","import { decorateImages } from './decorateImages';\n\n/**\n * This function is used to adjust the markup of a section.\n * It wraps the default content in a div with the class 'default-content-wrapper'.\n * It also adds the class 'section' to the section element.\n * It decorates the images in the default content by calling the 'decorateImages' function.\n * It sets the 'data-section-status' attribute to 'initialized'.\n * It hides the section element.\n * @param {HTMLDivElement} section - The section element to adjust.\n */\nexport function adjustMarkup(section: HTMLDivElement) {\n  const wrappers: HTMLDivElement[] = [];\n  let defaultContent = false;\n  [...section.children].forEach((e) => {\n    if (e.tagName === 'DIV' || !defaultContent) {\n      const wrapper = document.createElement('div');\n      wrappers.push(wrapper);\n      defaultContent = e.tagName !== 'DIV';\n\n      if (defaultContent) {\n        wrapper.classList.add('default-content-wrapper');\n      }\n    }\n    wrappers[wrappers.length - 1].append(e);\n  });\n  wrappers.forEach((wrapper) => section.append(wrapper));\n  decorateImages();\n  section.classList.add('section');\n  section.dataset.sectionStatus = 'initialized';\n  section.style.display = 'none';\n}\n","import { toClassName } from './toClassName';\n\n/**\n * Sanitizes a string for use as a JavaScript property name.\n *\n * @param {string} name - The unsanitized string.\n * @returns {string} - The camelCased name.\n *\n * @example\n * // Example usage:\n * const unsanitizedString = 'background-color';\n * const camelCasedName = toCamelCase(unsanitizedString);\n * console.log(camelCasedName); // Output: 'backgroundColor'\n */\nexport function toCamelCase(name: string): string {\n  if (/^[a-z][A-Za-z0-9]*$/.test(name)) {\n    return name;\n  }\n\n  if (/^[A-Z][A-Za-z0-9]*$/.test(name)) {\n    return name.charAt(0).toLowerCase() + name.slice(1);\n  }\n\n  return toClassName(name).replace(/-([a-z])/g, (g: string) => g[1].toUpperCase());\n}\n","import { toClassName } from '../../utils/toClassName';\n\n/*\n  This function reads the configuration of a block from the HTML file\n  and returns it as a Record<string, string | string[]> object.\n  @param {Element} block The block element\n*/\nexport function readBlockConfig(block: Element): Record<string, string | string[]> {\n  const config: Record<string, string | string[]> = {};\n  block.querySelectorAll(':scope > div').forEach((row) => {\n    if (row.children) {\n      const cols = [...row.children];\n      if (cols[1]) {\n        const col = cols[1];\n        const name = toClassName(cols[0].textContent ?? '');\n        let value: string | string[] = '';\n        if (col.querySelector('a')) {\n          const as = [...col.querySelectorAll('a')];\n          if (as.length === 1) {\n            value = as[0].href;\n          } else {\n            value = as.map((a) => a.href);\n          }\n        } else if (col.querySelector('img')) {\n          const imgs = [...col.querySelectorAll('img')];\n          if (imgs.length === 1) {\n            value = imgs[0].src;\n          } else {\n            value = imgs.map((img) => img.src);\n          }\n        } else if (col.querySelector('p')) {\n          const ps = [...col.querySelectorAll('p')];\n          if (ps.length === 1) {\n            value = ps[0].textContent!;\n          } else {\n            value = ps.map((p) => p.textContent!);\n          }\n        } else {\n          value = row.children[1].textContent!;\n        }\n        config[name] = value;\n      }\n    }\n  });\n  return config;\n}\n","import { toCamelCase } from '../../utils/toCamelCase';\nimport { toClassName } from '../../utils/toClassName';\nimport { readBlockConfig } from './readBlockConfig';\n\n/*\n  This function processes the metadata of a section and applies it to the section element.\n  @param {HTMLElement} section The section element\n*/\nexport function processSectionMetaData(section: HTMLElement) {\n  const sectionMeta = section.querySelector('div.section-metadata');\n  if (sectionMeta) {\n    const meta = readBlockConfig(sectionMeta);\n    Object.keys(meta).forEach((key) => {\n      if (key === 'style') {\n        const styles = (meta.style as string)\n          .split(',')\n          .filter((style: string) => style)\n          .map((style: string) => toClassName(style.trim()));\n        styles.forEach((style: string) => section.classList.add(style));\n      } else {\n        // @ts-ignore - browsers do seem to convert arrays via join(\",\") when setting the attribute value, although it is not in the spec\n        section.dataset[toCamelCase(key)] = meta[key];\n      }\n    });\n    if (sectionMeta.parentElement) sectionMeta.parentElement.remove();\n  }\n}\n","import { adjustMarkup } from './adjustMarkup';\nimport { processSectionMetaData } from './processSectionMetaData';\n\n/**\n * This function is used to transform the sections of the main element.\n * It adjusts the markup of each section by calling the 'adjustMarkup' function.\n * It processes the metadata of each section by calling the 'processSectionMetaData' function.\n * @param {HTMLElement} main - The main element to transform.\n */\nexport function transformSections(main: HTMLElement | null) {\n  main?.querySelectorAll<HTMLDivElement>(':scope > div').forEach((section) => {\n    adjustMarkup(section);\n    processSectionMetaData(section);\n  });\n}\n","/**\n * Wrap inline text content of block cells within a <p> tag.\n * @param {Element} block the block element\n */\nexport function wrapTextNodes(block: HTMLElement) {\n  const validWrappers = ['P', 'PRE', 'UL', 'OL', 'PICTURE', 'TABLE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'];\n\n  const wrap = (el: HTMLElement) => {\n    const wrapper = document.createElement('p');\n    wrapper.append(...el.childNodes);\n    [...el.attributes]\n      // move the instrumentation from the cell to the new paragraph, also keep the class\n      // in case the content is a buttton and the cell the button-container\n      .filter(\n        ({ nodeName }) =>\n          nodeName === 'class' || nodeName.startsWith('data-aue') || nodeName.startsWith('data-richtext')\n      )\n      .forEach(({ nodeName, nodeValue }) => {\n        wrapper.setAttribute(nodeName, nodeValue || '');\n        el.removeAttribute(nodeName);\n      });\n    el.append(wrapper);\n  };\n\n  block.querySelectorAll(':scope > div > div').forEach((blockColumn: HTMLElement) => {\n    if (blockColumn.hasChildNodes()) {\n      const hasWrapper =\n        Boolean(blockColumn.firstElementChild) &&\n        validWrappers.some((tagName) => blockColumn?.firstElementChild?.tagName === tagName);\n      if (!hasWrapper) {\n        wrap(blockColumn);\n      } else if (\n        blockColumn.firstElementChild?.tagName === 'PICTURE' &&\n        (blockColumn.children.length > 1 || Boolean(blockColumn.textContent?.trim()))\n      ) {\n        wrap(blockColumn);\n      }\n    }\n  });\n}\n","import { wrapTextNodes } from './wrapTextNodes';\n\n/**\n * Decorate block with classes and data attributes.\n * @param {HTMLElement | null} block - Html block element\n */\nexport function decorateBlock(block: HTMLElement | null) {\n  if (block) {\n    const shortBlockName = block.classList[0];\n    if (shortBlockName && !block.dataset.blockStatus) {\n      block.classList.add('block');\n      block.dataset.blockName = shortBlockName;\n      block.dataset.blockStatus = 'initialized';\n      wrapTextNodes(block);\n      const blockWrapper = block.parentElement;\n      blockWrapper?.classList.add(`${shortBlockName}-wrapper`);\n      const section = block.closest('.section');\n      if (section) section.classList.add(`${shortBlockName}-container`);\n    }\n  }\n}\n","import { decorateBlock } from './decorateBlock';\n\n/**\n * Decorate blocks with classes and data attributes.\n * @param {HTMLElement} main - Html main element\n */\nexport function decorateBlocks(main: HTMLElement | null) {\n  main?.querySelectorAll<HTMLDivElement>('div.section > div > div').forEach((block) => {\n    decorateBlock(block);\n  });\n}\n"],"file":"__chunks__/decorateBlocks.zO8n8sUO.js"}